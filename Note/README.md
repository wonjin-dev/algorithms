# 자료구조의 종류

> `단순 구조`, `선형 구조`, `비선형 구조`

## 단순구조

- 정수
- 실수
- 문자열
- 논리

## 선형 구조

> 한 원소 뒤에 하나의 원소만이 존재하여 자료들이 선형으로 나열되어 있는 구조

- 배열
- 연결 리스트
- 스택
- 큐

## 비선형 구조

> 원소 간에 다대다 관계를 가지는 구조

- 그래프
- 트리

<hr>

# 시간복잡도

> 소프트웨어의 성능은 명확하게 표현할 수 없다. 따라서 `빅오표기법`으로 표현한다 (시간복잡도 표현)

## 빅오표기법

<img width="1117" src="https://user-images.githubusercontent.com/82315118/210250252-ccd1198a-13b7-422c-bb18-7736edef55cf.png" />

( 상수함수 < 로그함수 < 선형함수 < 다항함수 < 지수함수 )

- 상수항은 무시한다
- 가장 큰 항 외에는 무시한다

```
O(1) : stack에서 Push, Pop

O(log n) : 이진 트리

O(n) : for loop

O(n log n) : 퀵 정렬, 병합정렬, 힙 정렬

O(n^2): 이중 for 문, 삽입정렬, 거품정렬, 선택정렬

O(2^n) : 피보나치 수열
```

# 큐와 스택

## 큐 (Queue)

> 선입선출 자료구조

(선출)`Front`, `Rear`(후출), `EnQueue`(==push), `DeQueue`(==pop)

- 큐는 배열로 구현하면 앞에 빠진 인덱스를 채우지 않기 때문에 사이즈가 무한정 늘어날 수 있다.
  > JS한정
  > 그렇다고 인덱스를 당기려면 선형시간이 소요 되기 때문에 배열이 아닌 연결 리스트로 큐를 구현하는 것이 올바르다
- 원형 큐 자료구조를 구현할 때는 배열로 구현해도 된다.
  > 한정된 공간을 사용할때 원형 큐를 이용하기 때문에 연결 리스트로 구현해도 이점이 없기 때문
- shift로 큐를 구현하는 것은 올바르지 않다.
  > shift는 선형시간이 소요

## 스택

후입선출 자료구조

**_코드로는 배열로 표현하는 것이 유리_**

# 연결 리스트 (Linked List)

연결 리스트는 각 노드를 포인터로 연결하여 관리하는 선형 자료구조

- 추가, 삭제가 많은 로직에 대하여 배열은 시간 복잡도가 높기 때문에 사용되는 자료구조
- 각 노드는 데이터 영역과 포인터 영역으로 구분된다

## 특징

- 메모리가 허용하면 제한없이 요소를 추가할 수 있다
- 탐색에 대해서는 선형시간이 소요된다
- 요소를 추가하거나 제거할 때는 상수시간이 소요된다
  > 따라서 요소의 추가/제거를 위해 탐색 로직이 추가되지 않게 유의해야 한다
- 총 3가지 종류가 있다
  > `singly linked list`, `doubly linked list`, `circular linked list`

## 단방향 연결 리스트

- 단방향으로 연결된 선형 자료구조
  - JavaScript에서의 배열은 동적 메모리 할당을 사용하므로, 연결 리스트와 더 가깝다.
- 삽입과 삭제에 유리
  - 삽입과 삭제가 자주 발생하는 경우, 연결 리스트는 노드의 연결만 변경하면 되므로 효율적이다.
- 연결 리스트는 인덱스 개념이 없다
  > 연속적인 메모리 공간에 저장되지 않으므로 인덱스 개념이 없다.
  - 헤드와 테일이라는 포인터를 사용하여 리스트를 탐색한다.
  - 스택과 큐와 같은 추상 데이터 타입의 구현에 사용한다.

## vs Array

- `Array` 정적할당
- `Linked List` 동적할당

### 배열의 특징

- 원소를 삭제하면 해당 index는 비게 된다
- 특정 요소를 삭제하거나 추가할때는 선형시간O(n)이 소요된다

**_즉, 추가나 삭제가 잦은 로직이라면 배열을 사용하는 것은 좋지 않다. 탐색의 경우에 유리한 자료 구조_**

<br/>

# 이진 트리

> 정점이 최대 두개인 트리

## 구현 방법

배열 혹은 요소에 링크가 2개 존재하는 연결 리스트로 구현할 수 있다.

## 특징

- 정렬 되어있는 요소들을 반씩 제외하며 찾는 알고리즘
- `log n`의 시간복잡도를 가진다.
- 최악의 경우 이진 트리의 높이는 정점의 개수까지 늘어날 수 있다
- 정점이 N개인 포화 또는 완전 이진 트리는의 높이는 **_logN_**
- 높이가 h인 포화 이진 트리는 **_2^h-1 개의 정점_**을 가진다

<hr/>

# 이진 탐색 트리 (BST)

> Binary Search Tree

이진 탐색을 위한 이진 트리. 왼쪽 서브 트리는 루트보다 작은 값이 모여있고, 오른쪽 서브 트리는 루트보다 큰 값이 모이게 된다.

## 특징

- **_반드시 정렬되어있어야 사용할 수 있다_**
- 배열 또는 이진 트리를 이용해 구현할 수 있다.
- 빠르다.

## 이진 탐색 트리

이진 탐색을 위한 이진 트리. 왼쪽 서브 트리는 루트보다 작은 값이 모여있고, 오른쪽 서브 트리는 루트보다 큰 값이 모이게 된다.

### 이진 탐색 트리의 문제점

- 최악의 경우 한쪽으로 편향된 트리가 생성될 수 있음(순차 탐색과 동일한 시간복잡도)
  - 해결을 위한 자료구조
    - AVL트리
    - 레드-블랙 트리

# 그래프

> 정점과 정점(노드) 사이를 간선으로 연결한 자료구조

## 특징

- 정점은 여러 개의 간선을 가질 수 있다.
- `방향 그래프`와 `무방향 그래프`로 나눌 수 있다.
- 간선은 가중치를 가질 수 있다.
- 사이클이 발생할 수 있다.

## 무방향 그래프

양방향으로 이동 가능

## 완전 그래프

모든 정점이 연결되어 있는 상태

# BFS (너비 우선 탐색, Breadth-First Search)

> 그래프 탐색 알고리즘으로 같은 깊이에 해당하는 정점부터 탐색하는 알고리즘

## 특징

- 큐를 이용하여 구현할 수 있다.
- 시작 지점에서 가까운 정점부터 탐색한다.
- v가 정점수 e가 간선 수 일때 `시간복잡도는 상수시간` (v+e) 이다.

# DFS (깊이 우선 탐색, Depth-First Search)

> 그래프 탐색 알고리즘으로 최대한 깊은 정점부터 탐색하는 알고리즘

## 특징

- 스택을 이용하여 구현할 수 있다
- 시작 정점에서 깊은 것 부터 찾는다
- v가 정점수 e가 간선 수 일때 `시간복잡도는 상수시간` (v+e) 이다

## DFS 세 가지 주요 탐색 방법

- Pre-Order Traversal (전위 순회): 루트 -> 왼쪽 하위 트리 -> 오른쪽 하위 트리
- In-Order Traversal (중위 순회): 왼쪽 하위 트리 -> 루트 -> 오른쪽 하위 트리
- Post-Order Traversal (후위 순회): 왼쪽 하위 트리 -> 오른쪽 하위 트리 -> 루트

### Post Order Traversal

DFS는 트리나 그래프를 탐색하는 알고리즘으로, 루트에서 시작하여 가능한 한 깊게 노드를 탐색하고, 더 이상 탐색할 노드가 없으면 이전 노드로 돌아가는 방식.
<br/>
Post Order Traversal은 노드를 '왼쪽 하위 트리 -> 오른쪽 하위 트리 -> 루트' 순서로 방문하기 때문에 트리의 노드를 삭제하거나, 트리를 복사하거나, 트리를 뒤집는 등의 작업을 할 때 유용.

# 트라이

비선형 자료구조.<br/>
문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조이다.

## 특징

- 검색어 자동완성, 사전 찾기에 응용 가능하다.
- 문자열을 탐색할 때 단순하게 비교하는 것보다 효율적으로 찾을 수 있다.
- L이 문자열의 길ㅇ디일 때 탐색,삽입은 상수시간이 소요된다.
- 대신 각 정점이 자식에 대한 링크를 전부 가지고 있기에 메모리를 더 많이 사용한다.

## 구조

- 루트는 비어있다.
- 각 링크는 추가될 문자를 키로 가진다.
- 각 정점은 이전 정점의 값 + 간선의 키를 값으로 가진다.
- 해시 테이블과 연결리스트를 활용하여 구현할 수 있다.
